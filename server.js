const express = require('express');
const path = require('path');
const cors = require('cors');
const compression = require('compression');

console.log('üöÄ Starting CliqPages server...');
console.log('üìç Node.js version:', process.version);
console.log('üåç Environment:', process.env.NODE_ENV || 'development');

const app = express();
const PORT = process.env.PORT || 3000;

console.log('üîß PORT:', PORT);

// Middleware
app.use(compression()); // Enable gzip compression
app.use(cors());
app.use(express.json({ limit: '10mb' }));
app.use(express.static('.'));

// AI provider configuration
const aiProvider = process.env.AI_PROVIDER || 'claude';

// Email sending function
async function sendEmailNotification(formData, result) {
  if (!process.env.RESEND_API_KEY) {
    console.log('‚ö†Ô∏è No Resend API key found, skipping email');
    return;
  }

  try {
    const { Resend } = require('resend');
    const resend = new Resend(process.env.RESEND_API_KEY);

    const emailHtml = `
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%); color: white; padding: 30px; text-align: center; border-radius: 8px 8px 0 0; }
        .content { background: #f8fafc; padding: 30px; border-radius: 0 0 8px 8px; }
        .button { display: inline-block; background: #3b82f6; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; font-weight: 600; margin: 10px 0; }
        .footer { text-align: center; padding: 20px; color: #666; font-size: 14px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéâ Your Landing Page is Ready!</h1>
            <p>Generated by CliqPages AI</p>
        </div>
        <div class="content">
            <h2>Hi there!</h2>
            <p>Great news! Your professional landing page for <strong>${formData.businessName || 'your business'}</strong> has been successfully generated using Claude AI.</p>
            
            <p><strong>What's included:</strong></p>
            <ul>
                <li>‚úÖ Professional, conversion-optimized design</li>
                <li>‚úÖ Mobile-responsive layout</li>
                <li>‚úÖ Custom brand colors and messaging</li>
                <li>‚úÖ SEO-friendly structure</li>
                <li>‚úÖ Contact forms and call-to-action buttons</li>
            </ul>

            <p>Your landing page is attached as an HTML file. Simply download it and upload to your web hosting provider!</p>
            
            <div style="text-align: center; margin: 30px 0;">
                <p style="color: #666;">Having trouble with the attachment? Contact us for support.</p>
            </div>
        </div>
        <div class="footer">
            <p>Generated by <strong>CliqPages</strong> - AI-Powered Landing Page Generator</p>
            <p>Need help? Reply to this email for support.</p>
        </div>
    </div>
</body>
</html>`;

    // Use Resend's default domain or your verified domain
    const fromEmail = process.env.FROM_EMAIL || 'CliqPages <onboarding@resend.dev>';
    
    await resend.emails.send({
      from: fromEmail,
      to: [formData.email],
      subject: `üéâ Your ${formData.businessName || 'Business'} Landing Page is Ready!`,
      html: emailHtml,
      attachments: [
        {
          filename: result.fileName,
          content: Buffer.from(result.htmlContent).toString('base64'),
        },
      ],
    });

    console.log('‚úÖ Email sent successfully to:', formData.email);
    console.log('üìß Email details:', {
      from: fromEmail,
      to: formData.email,
      subject: `üéâ Your ${formData.businessName || 'Business'} Landing Page is Ready!`,
      attachmentSize: result.htmlContent?.length || 0
    });
  } catch (error) {
    console.error('‚ùå Email sending failed:', error);
    console.error('üìß Email error details:', {
      message: error.message,
      name: error.name,
      status: error.status || 'unknown',
      formDataEmail: formData.email,
      hasApiKey: !!process.env.RESEND_API_KEY
    });
  }
}

// Direct implementation of landing page generation
async function generateLandingPage(formData, sessionId = null) {
  console.log('üìù Generating landing page with form data:', Object.keys(formData));
  
  // Send initial progress update
  if (sessionId) {
    sendProgressUpdate(sessionId, {
      type: 'progress',
      stage: 'initializing',
      message: 'Initializing AI generation...',
      percentage: 5,
      icon: 'üöÄ'
    });
  }
  
  const businessName = formData.businessName || 'Your Business';
  const businessDesc = formData.businessDescription || 'Professional services and solutions';
  const primaryColor = formData.primaryColor || '#3b82f6';
  const secondaryColor = formData.secondaryColor || '#1e40af';
  const targetAudience = formData.targetAudience || 'professionals and businesses';
  const contactInfo = formData.contactInfo || 'contact@yourbusiness.com';
  const primaryGoal = formData.primaryGoal || 'generate leads';
  const pageStyle = formData.style || 'Professional';
  const designInstructions = formData.customInstructions || '';
  const phoneNumber = formData.phoneNumber || '';
  
  let result;
  
  // PRIORITY 1: Use Elite Multi-Gen (section-by-section) if API key available
  if (process.env.ANTHROPIC_API_KEY) {
    console.log('üöÄ Using ELITE MULTI-GEN (section-by-section generation)');
    
    // Transform form data to elite format
    const eliteInput = {
      email: formData.email || contactInfo,
      business_email: formData.businessEmail || formData.email || contactInfo,
      phone_number: formData.phoneNumber || phoneNumber,
      company_name: formData.businessName || businessName,
      business_description: formData.businessDescription || businessDesc,
      target_audience: formData.targetAudience || targetAudience,
      page_style: formData.pageStyle || pageStyle,
      primary_goal: formData.primaryGoal || primaryGoal,
      primary_color: formData.primaryColor || primaryColor,
      secondary_color: formData.secondaryColor || secondaryColor,
      custom_instructions: formData.customInstructions || designInstructions,
      website_url: formData.websiteUrl || ''
    };
    
    try {
      if (sessionId) {
        sendProgressUpdate(sessionId, {
          type: 'progress',
          stage: 'starting_sections',
          message: 'Starting section-by-section generation...',
          percentage: 10,
          icon: 'üèóÔ∏è'
        });
      }
      
      const eliteGen = require('./elite-multi-gen-api');
      result = await eliteGen.generateWithProgress(eliteInput, (progress, message, sectionName) => {
        console.log(`üìä Progress: ${progress}% - ${message}`);
        
        // Send real-time progress updates
        if (sessionId) {
          sendProgressUpdate(sessionId, {
            type: 'progress',
            stage: 'generating_section',
            message: message,
            percentage: Math.round(progress),
            currentSection: sectionName,
            icon: progress < 90 ? '‚ö°' : 'üé®'
          });
        }
      });
      
      if (result.success) {
        result.message = `Landing page generated using ELITE multi-section approach. ${result.sectionsGenerated?.length || 'Multiple'} sections created.`;
        result.isElite = true;
      }
    } catch (error) {
      console.error('‚ùå Elite generation failed, falling back to single-prompt method:', error);
      result = await generateWithClaude(formData);
    }
  } else if (aiProvider === 'openai' && process.env.OPENAI_API_KEY) {
    result = await generateWithOpenAI(formData);
  } else {
    result = await generateDemoPage(formData);
  }

  // Send email notification if successful and not demo mode
  if (result.success && !result.isDemo && formData.email) {
    await sendEmailNotification(formData, result);
  }

  return result;
}

// Helper function to clean HTML response
function cleanHtmlResponse(htmlContent) {
  console.log('üßπ Cleaning HTML response...');
  
  // Remove any markdown code blocks or explanatory text
  htmlContent = htmlContent.replace(/```html\s*/g, '').replace(/```\s*$/g, '');
  
  // Remove any introductory text before DOCTYPE
  if (htmlContent.includes('<!DOCTYPE html>')) {
    const htmlStart = htmlContent.indexOf('<!DOCTYPE html>');
    const htmlEnd = htmlContent.lastIndexOf('</html>') + 7;
    
    if (htmlStart !== -1 && htmlEnd !== -1) {
      htmlContent = htmlContent.substring(htmlStart, htmlEnd);
    }
  } else {
    // If no DOCTYPE found, try to extract from any HTML tags
    const htmlMatch = htmlContent.match(/<html[\s\S]*?<\/html>/i);
    if (htmlMatch) {
      htmlContent = '<!DOCTYPE html>\n' + htmlMatch[0];
    }
  }
  
  console.log('‚úÖ HTML response cleaned');
  return htmlContent.trim();
}

// NEW APPROACH: Context Processing + Pure Generation
async function generateWithClaude(formData) {
  const Anthropic = require('@anthropic-ai/sdk');
  const anthropic = new Anthropic({
    apiKey: process.env.ANTHROPIC_API_KEY,
  });

  // Debug: Log all form data to see what we're receiving
  console.log('üîç Form data received:', JSON.stringify(formData, null, 2));
  
  const businessName = formData.businessName || formData.business_name || 'Your Business';
  const businessDesc = formData.businessDescription || formData.business_description || 'Professional services and solutions';
  const primaryColor = formData.primaryColor || formData.primary_color || '#3b82f6';
  const secondaryColor = formData.secondaryColor || formData.secondary_color || '#1e40af';
  const targetAudience = formData.targetAudience || formData.target_audience || 'professionals and businesses';
  const contactInfo = formData.contactInfo || formData.email || 'contact@yourbusiness.com';
  const primaryGoal = formData.primaryGoal || formData.primary_goal || 'generate leads';
  const pageStyle = formData.style || formData.page_style || 'Professional';
  const designInstructions = formData.customInstructions || formData.custom_instructions || '';
  const phoneNumber = formData.phoneNumber || formData.phone_number || '';
  
  // Debug: Log extracted values
  console.log('üîç Extracted values:', {
    businessName,
    businessDesc,
    primaryColor,
    secondaryColor,
    targetAudience,
    contactInfo,
    primaryGoal,
    pageStyle,
    designInstructions,
    phoneNumber
  });

  console.log('üöÄ Starting NEW APPROACH: Context Processing + Pure Generation');

      // CALL 1: Context Processing & Understanding (FORCED COMPLIANCE)
    const contextPrompt = `BUSINESS: ${businessName}
DESCRIPTION: ${businessDesc}
TARGET: ${targetAudience}
GOAL: ${primaryGoal}
COLORS: ${primaryColor}, ${secondaryColor}
CONTACT: ${contactInfo}

You will create a complete landing page. Use "${businessName}" throughout. Include all sections: nav, hero, features, testimonials, pricing, FAQ, contact. 

Reply with: "Ready to generate ${businessName} landing page."`;

  console.log('üîç CALL 1: Processing business context and requirements...');
  console.log('üîç Context prompt length:', contextPrompt.length);

  // Claude API function with custom max tokens
  async function callClaudeAPIWithMaxTokens(prompt, maxTokens) {
    const maxRetries = 3;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        console.log(`üîç Making Claude API call (attempt ${attempt}/${maxRetries})`);
        console.log('üîç Max tokens:', maxTokens);
        console.log('üîç Prompt length:', prompt.length, 'characters');
        
        // Add timeout to the API call
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
        
        const response = await anthropic.messages.create({
          model: 'claude-3-5-sonnet-20241022',
          max_tokens: maxTokens,
          temperature: 0.7,
          messages: [{ role: 'user', content: prompt }]
        });
        
        clearTimeout(timeoutId);
        
        console.log('‚úÖ Claude API call successful!');
        const content = response.content[0].text;
        console.log('üîç Response length:', content.length, 'characters');
        console.log('üîç Response preview:', content.substring(0, 200) + '...');
        
        // Log token usage information
        if (response.usage) {
          console.log('üìä TOKEN USAGE DETAILS:');
          console.log('üîç Input tokens:', response.usage.input_tokens);
          console.log('üîç Output tokens:', response.usage.output_tokens);
          console.log('üîç Total tokens:', response.usage.input_tokens + response.usage.output_tokens);
          console.log('üîç Max tokens allowed:', maxTokens);
          console.log('üîç Token utilization:', Math.round(((response.usage.input_tokens + response.usage.output_tokens) / maxTokens) * 100) + '%');
        }
        
        return content;
        
      } catch (error) {
        console.log(`‚ùå Attempt ${attempt} failed:`, error.message);
        console.log(`üîç Error status: ${error.status}`);
        console.log(`üîç Error type: ${error.error?.error?.type}`);
        
        // Handle specific error types
        if (error.name === 'AbortError') {
          throw new Error('Claude API timeout after 30 seconds');
        }
        
        // If it's an overloaded error (529) and we have retries left, wait and retry
        if (error.status === 529 && attempt < maxRetries) {
          const waitTime = Math.pow(2, attempt) * 1000; // Exponential backoff: 2s, 4s, 8s
          console.log(`‚è≥ Server overloaded. Waiting ${waitTime}ms before retry ${attempt + 1}/${maxRetries}...`);
          await new Promise(resolve => setTimeout(resolve, waitTime));
          continue;
        }
        
        // If it's a 400 error (bad request), don't retry
        if (error.status === 400) {
          throw error;
        }
        
        // If not an overloaded error or no retries left, throw the error
        if (attempt === maxRetries) {
          throw error;
        }
      }
    }
  }

  // Claude API function with conversation history support
  async function callClaudeAPIWithHistory(messages) {
    const maxRetries = 3;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        console.log(`üîç Making Claude API call with history (attempt ${attempt}/${maxRetries})`);
        console.log('üîç Messages count:', messages.length);
        console.log('üîç Max tokens: 8192');
        console.log('üîç Target: Use ALL 8192 tokens for comprehensive content');
        
        // Add timeout to the API call (reduced for faster processing)
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 25000); // 25 second timeout
        
        const response = await anthropic.messages.create({
          model: 'claude-3-5-sonnet-20241022',
          max_tokens: 8192,
          temperature: 0.7,
          messages: messages,
        });
        
        clearTimeout(timeoutId);
        
        console.log('‚úÖ Claude API call successful!');
        const content = response.content[0].text;
        console.log('üîç Response length:', content.length, 'characters');
        console.log('üîç Response preview:', content.substring(0, 200) + '...');
        
        // Log token usage information
        if (response.usage) {
          console.log('üìä TOKEN USAGE DETAILS:');
          console.log('üîç Input tokens:', response.usage.input_tokens);
          console.log('üîç Output tokens:', response.usage.output_tokens);
          console.log('üîç Total tokens:', response.usage.input_tokens + response.usage.output_tokens);
          console.log('üîç Max tokens allowed: 8192');
          console.log('üîç Token utilization:', Math.round(((response.usage.input_tokens + response.usage.output_tokens) / 8192) * 100) + '%');
          
          // Character to token ratio analysis
          const totalChars = messages.reduce((sum, msg) => sum + msg.content.length, 0) + content.length;
          const totalTokens = response.usage.input_tokens + response.usage.output_tokens;
          console.log('üîç Character to token ratio:', Math.round(totalChars / totalTokens * 100) / 100, 'chars per token');
          console.log('üîç Total characters:', totalChars);
        }
        
        return content;
        
      } catch (error) {
        console.log(`‚ùå Attempt ${attempt} failed:`, error.message);
        console.log(`üîç Error status: ${error.status}`);
        console.log(`üîç Error type: ${error.error?.error?.type}`);
        
        // Handle specific error types
        if (error.name === 'AbortError') {
          throw new Error('Claude API timeout after 25 seconds');
        }
        
        // If it's an overloaded error (529) and we have retries left, wait and retry
        if (error.status === 529 && attempt < maxRetries) {
          const waitTime = Math.pow(2, attempt) * 1000; // Exponential backoff: 2s, 4s, 8s
          console.log(`‚è≥ Server overloaded. Waiting ${waitTime}ms before retry ${attempt + 1}/${maxRetries}...`);
          await new Promise(resolve => setTimeout(resolve, waitTime));
          continue;
        }
        
        // If it's a 400 error (bad request), don't retry
        if (error.status === 400) {
          throw error;
        }
        
        // If not an overloaded error or no retries left, throw the error
        if (attempt === maxRetries) {
          throw error;
        }
      }
    }
  }

  // Improved Claude API function (inspired by PageCraft)
  async function callClaudeAPI(prompt, expectJson = false) {
    const maxRetries = 3;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        console.log(`üîç Making Claude API call (attempt ${attempt}/${maxRetries}) with model: claude-3-5-sonnet-20241022`);
        console.log('üîç Prompt length:', prompt.length);
        console.log('üîç Max tokens:', expectJson ? 2000 : 8192);
        console.log('üîç Target: Use ALL 8192 tokens for comprehensive content');
        
        // Add timeout to the API call (reduced for faster processing)
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 25000); // 25 second timeout
        
        const response = await anthropic.messages.create({
          model: 'claude-3-5-sonnet-20241022',
          max_tokens: expectJson ? 2000 : 8192,
          temperature: 0.7,
          messages: [{ role: 'user', content: prompt }],
        });
        
        clearTimeout(timeoutId);
        
        console.log('‚úÖ Claude API call successful!');
        const content = response.content[0].text;
        console.log('üîç Response length:', content.length, 'characters');
        console.log('üîç Response preview:', content.substring(0, 200) + '...');
        
        // Log token usage information
        if (response.usage) {
          console.log('üìä TOKEN USAGE DETAILS:');
          console.log('üîç Input tokens:', response.usage.input_tokens);
          console.log('üîç Output tokens:', response.usage.output_tokens);
          console.log('üîç Total tokens:', response.usage.input_tokens + response.usage.output_tokens);
          console.log('üîç Max tokens allowed:', expectJson ? 2000 : 8192);
          console.log('üîç Token utilization:', Math.round(((response.usage.input_tokens + response.usage.output_tokens) / (expectJson ? 2000 : 8192)) * 100) + '%');
          
          // Character to token ratio analysis
          const totalChars = prompt.length + content.length;
          const totalTokens = response.usage.input_tokens + response.usage.output_tokens;
          console.log('üîç Character to token ratio:', Math.round(totalChars / totalTokens * 100) / 100, 'chars per token');
          console.log('üîç Total characters:', totalChars);
        }
        
        if (expectJson) {
          // Try to parse JSON from the response
          try {
            const jsonMatch = content.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
              return JSON.parse(jsonMatch[0]);
            }
          } catch (e) {
            console.error('Error parsing JSON from API response:', e);
            throw new Error('Invalid response format from API');
          }
          throw new Error('Invalid response format from API');
        } else {
          // Return raw content (for HTML landing page)
          return content;
        }
        
      } catch (error) {
        console.log(`‚ùå Attempt ${attempt} failed:`, error.message);
        console.log(`üîç Error status: ${error.status}`);
        console.log(`üîç Error type: ${error.error?.error?.type}`);
        
        // Handle specific error types
        if (error.name === 'AbortError') {
          throw new Error('Claude API timeout after 25 seconds');
        }
        
        // If it's an overloaded error (529) and we have retries left, wait and retry
        if (error.status === 529 && attempt < maxRetries) {
          const waitTime = Math.pow(2, attempt) * 1000; // Exponential backoff: 2s, 4s, 8s
          console.log(`‚è≥ Server overloaded. Waiting ${waitTime}ms before retry ${attempt + 1}/${maxRetries}...`);
          await new Promise(resolve => setTimeout(resolve, waitTime));
          continue;
        }
        
        // If it's a 400 error (bad request), don't retry
        if (error.status === 400) {
          throw error;
        }
        
        // If not an overloaded error or no retries left, throw the error
        if (attempt === maxRetries) {
          throw error;
        }
      }
    }
  }

  try {
    // CALL 1: Context Processing (simple and direct)
    let contextResponse = await callClaudeAPI(contextPrompt, false);
    console.log('‚úÖ Context processing completed');
    console.log('üîç Context response length:', contextResponse.length, 'characters');
    console.log('üîç Context response preview:', contextResponse.substring(0, 200) + '...');

    // CALL 2: Pure Generation (DIRECT COMMAND)
    const generationPrompt = `Create complete landing page for ${businessName}. 

Requirements:
- Use "${businessName}" 15+ times
- Professional design with ${primaryColor} and ${secondaryColor}
- All sections: nav, hero, features, testimonials, pricing, FAQ, contact
- Modern CSS with animations
- JavaScript interactions
- Mobile responsive
- Target: ${targetAudience}
- Goal: ${primaryGoal}

Return only HTML code starting with <!DOCTYPE html>:`;

    console.log('üîç CALL 2: Generating complete landing page...');
    console.log('üîç Generation prompt length:', generationPrompt.length);
    
    // Use conversation history for context continuity
    let finalHtml = await callClaudeAPIWithHistory([
      { role: 'user', content: contextPrompt },
      { role: 'assistant', content: contextResponse },
      { role: 'user', content: generationPrompt }
    ]);
    
    console.log('‚úÖ Pure generation completed');
    console.log('üîç Final output length:', finalHtml.length, 'characters');

    // Clean and validate final HTML
    finalHtml = cleanHtmlResponse(finalHtml);
    
    // Verify we have valid final HTML
    if (!finalHtml.includes('<!DOCTYPE html>') || !finalHtml.includes('</html>')) {
      console.log('‚ö†Ô∏è Generation failed - invalid final HTML');
      console.log('üîç Response preview:', finalHtml.substring(0, 500));
      return await generateDemoPage(formData);
    }

    // Verify business name integration
    const businessNameCount = (finalHtml.match(new RegExp(businessName, 'gi')) || []).length;
    const yourBusinessCount = (finalHtml.match(/your business/gi) || []).length;
    const hasCSS = finalHtml.includes('<style>') || finalHtml.includes('style=');
    const hasJS = finalHtml.includes('<script>');
    
    console.log('üìä NEW APPROACH GENERATION SUMMARY:');
    console.log('üîç Context processing length:', contextResponse.length, 'characters');
    console.log('üîç Final generation length:', finalHtml.length, 'characters');
    console.log('üîç Business name occurrences:', businessNameCount);
    console.log('üîç "Your Business" occurrences:', yourBusinessCount);
    console.log('üîç CSS styling present:', hasCSS ? 'YES' : 'NO');
    console.log('üîç JavaScript present:', hasJS ? 'YES' : 'NO');
    console.log('üîç Primary color used:', primaryColor);
    console.log('üîç Secondary color used:', secondaryColor);
    
    if (businessNameCount < 5) {
      console.log('‚ö†Ô∏è Business name integration may be low');
    }
    if (!hasCSS) {
      console.log('‚ö†Ô∏è CSS styling may be missing');
    }
    
    return {
      success: true,
      htmlContent: finalHtml,
      fileName: `${businessName.toLowerCase().replace(/[^a-z0-9]/g, '-')}-landing-page.html`,
      message: 'Landing page generated successfully with NEW Context + Generation approach!',
      isDemo: false,
      generationMethod: 'context-generation',
      contextLength: contextResponse.length,
      finalLength: finalHtml.length,
      businessNameCount: businessNameCount,
      hasCSS: hasCSS,
      hasJS: hasJS
    };
  } catch (error) {
    console.error('‚ùå NEW APPROACH Error after retries:', error.message);
    console.error('üîç Error status:', error.status);
    console.error('üîç Error type:', error.error?.error?.type);
    
    // Fallback to demo mode if AI fails after retries
    console.log('üîÑ Falling back to demo mode...');
    return await generateDemoPage(formData);
  }
}

// Demo page generation (fallback)
async function generateDemoPage(formData) {
  const businessName = formData.businessName || 'Your Business';
  const businessDesc = formData.businessDescription || 'Professional services and solutions';
  const primaryColor = formData.primaryColor || '#3b82f6';
  const secondaryColor = formData.secondaryColor || '#1e40af';
  const targetAudience = formData.targetAudience || 'professionals and businesses';
  const contactInfo = formData.contactInfo || 'contact@yourbusiness.com';
  const primaryGoal = formData.primaryGoal || 'generate leads';
  
  const htmlContent = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${businessName} - Transform Your Business Today</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 1200px; margin: 0 auto; padding: 0 2rem; }
        
        .hero { background: linear-gradient(135deg, ${primaryColor} 0%, ${secondaryColor} 100%); color: white; padding: 6rem 0; text-align: center; }
        .hero h1 { font-size: 3.5rem; margin-bottom: 1.5rem; font-weight: 800; }
        .hero p { font-size: 1.4rem; margin-bottom: 3rem; opacity: 0.95; }
        .cta-button { 
            display: inline-block; background: white; color: ${primaryColor}; 
            padding: 1.2rem 2.5rem; text-decoration: none; border-radius: 8px; 
            font-weight: 700; font-size: 1.1rem; transition: all 0.3s;
        }
        .cta-button:hover { transform: translateY(-3px); box-shadow: 0 8px 25px rgba(0,0,0,0.15); }
        
        .features { padding: 6rem 0; background: #f8fafc; }
        .features h2 { text-align: center; font-size: 2.5rem; margin-bottom: 3rem; color: ${primaryColor}; }
        .features-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 2.5rem; }
        .feature { background: white; padding: 3rem; border-radius: 12px; text-align: center; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }
        .feature-icon { background: ${primaryColor}; color: white; width: 80px; height: 80px; border-radius: 50%; 
                       display: flex; align-items: center; justify-content: center; margin: 0 auto 2rem; font-size: 2rem; }
        .feature h3 { color: ${primaryColor}; margin-bottom: 1.5rem; font-size: 1.5rem; }
        
        .contact { padding: 6rem 0; background: white; text-align: center; }
        .contact h2 { font-size: 2.5rem; margin-bottom: 3rem; color: ${primaryColor}; }
        .contact-form { max-width: 600px; margin: 0 auto; }
        .form-group { margin-bottom: 1.5rem; }
        .form-group input, .form-group textarea { 
            width: 100%; padding: 1rem; border: 2px solid #e5e7eb; border-radius: 8px; 
            font-size: 1rem;
        }
        .submit-btn { 
            width: 100%; background: ${primaryColor}; color: white; padding: 1.2rem; 
            border: none; border-radius: 8px; font-weight: 600; font-size: 1.1rem; cursor: pointer;
        }
        
        .footer { background: #1a202c; color: white; padding: 3rem 0; text-align: center; }
        
        @media (max-width: 768px) {
            .hero h1 { font-size: 2.5rem; }
            .container { padding: 0 1rem; }
        }
    </style>
</head>
<body>
    <header class="hero">
        <div class="container">
            <h1>Transform Your Business with ${businessName}</h1>
            <p>${businessDesc}</p>
            <a href="#contact" class="cta-button">Get Started Today</a>
        </div>
    </header>

    <section class="features">
        <div class="container">
            <h2>Why Choose ${businessName}?</h2>
            <div class="features-grid">
                <div class="feature">
                    <div class="feature-icon">‚ö°</div>
                    <h3>Fast & Reliable</h3>
                    <p>Quick results designed for ${targetAudience} to help you ${primaryGoal}.</p>
                </div>
                <div class="feature">
                    <div class="feature-icon">üéØ</div>
                    <h3>Targeted Solutions</h3>
                    <p>Customized approaches for your unique business needs.</p>
                </div>
                <div class="feature">
                    <div class="feature-icon">üìà</div>
                    <h3>Proven Results</h3>
                    <p>Track record of success across industries.</p>
                </div>
            </div>
        </div>
    </section>

    <section class="contact" id="contact">
        <div class="container">
            <h2>Ready to Get Started?</h2>
            <form class="contact-form">
                <div class="form-group">
                    <input type="text" placeholder="Your Name" required>
                </div>
                <div class="form-group">
                    <input type="email" placeholder="Your Email" required>
                </div>
                <div class="form-group">
                    <textarea placeholder="Tell us about your needs" rows="4" required></textarea>
                </div>
                <button type="submit" class="submit-btn">Send Message</button>
            </form>
        </div>
    </section>

    <footer class="footer">
        <div class="container">
            <p>&copy; 2024 ${businessName}. All rights reserved.</p>
            <p>Contact: ${contactInfo}</p>
        </div>
    </footer>

    <script>
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                document.querySelector(this.getAttribute('href')).scrollIntoView({
                    behavior: 'smooth'
                });
            });
        });
    </script>
</body>
</html>`;

  return {
    success: true,
    htmlContent: htmlContent,
    fileName: `${businessName.toLowerCase().replace(/[^a-z0-9]/g, '-')}-landing-page.html`,
    message: 'Landing page generated successfully!'
  };
}

// Health check endpoint
app.get('/health', (req, res) => {
  const healthCheck = {
    status: 'healthy',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    environment: process.env.NODE_ENV || 'development',
    port: PORT,
    memory: process.memoryUsage(),
    version: process.version
  };
  
  console.log('üè• Health check requested:', healthCheck.timestamp);
  res.status(200).json(healthCheck);
});

// API Routes
// Claude API endpoint (PageCraft style)
app.post('/api/claude', async (req, res) => {
  try {
    const { model, max_tokens, temperature, messages } = req.body;
    
    console.log('üîç Direct Claude API call received');
    console.log('üîç Model:', model);
    console.log('üîç Max tokens:', max_tokens);
    console.log('üîç Temperature:', temperature);
    
    const Anthropic = require('@anthropic-ai/sdk');
    const anthropic = new Anthropic({
      apiKey: process.env.ANTHROPIC_API_KEY,
    });
    
    const response = await anthropic.messages.create({
      model: model || 'claude-3-5-sonnet-20241022',
      max_tokens: max_tokens || 8192,
      temperature: temperature || 0.5,
      messages: messages,
    });
    
    res.json({
      content: response.content,
      usage: response.usage
    });
    
  } catch (error) {
    console.error('‚ùå Claude API endpoint error:', error);
    res.status(error.status || 500).json({
      error: error.message,
      type: error.error?.error?.type || 'api_error'
    });
  }
});

app.post('/api/generate-landing-page', async (req, res) => {
  // Set extended response timeout for section-by-section generation
  res.setTimeout(720000); // 12 minutes for full generation
  
  // Set keep-alive headers to prevent gateway timeout
  res.setHeader('Connection', 'keep-alive');
  res.setHeader('Keep-Alive', 'timeout=720, max=1');
  
  try {
    console.log('üìù Landing page generation requested');
    console.log('üîç Request body keys:', Object.keys(req.body));
    console.log('üîç Memory usage before:', process.memoryUsage().heapUsed / 1024 / 1024, 'MB');
    
    // Generate or use provided session ID for progress tracking
    const sessionId = req.body.sessionId || Date.now().toString();
    
    // Track request start time for Railway timeout management
    const requestStartTime = Date.now();
    
    // Validate required fields
    if (!req.body.email) {
      return res.status(400).json({
        error: 'Missing required field',
        message: 'Email is required',
        timestamp: new Date().toISOString()
      });
    }

    // Add timeout wrapper for section-by-section generation (increased for 13 sections + assembly)
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => reject(new Error('Generation timeout after 600 seconds')), 600000); // 10 minutes for 13 sections
    });
    
    // Pass sessionId to generation function for progress tracking
    const generationPromise = generateLandingPage(req.body, sessionId);
    
    const result = await Promise.race([generationPromise, timeoutPromise]);
    
    console.log('‚úÖ Landing page generated successfully');
    console.log('üîç Memory usage after:', process.memoryUsage().heapUsed / 1024 / 1024, 'MB');
    console.log('üîç HTML content length:', result.htmlContent?.length || 0, 'characters');
    
    // Prepare response
    const responseData = {
      success: result.success,
      message: result.message,
      fileName: result.fileName,
      businessName: req.body.businessName,
      isDemo: result.isDemo || false,
      htmlContent: result.htmlContent,
      timestamp: new Date().toISOString()
    };
    
    // Log response size
    const responseSize = JSON.stringify(responseData).length;
    console.log('üîç Response size:', responseSize, 'bytes', '(', Math.round(responseSize / 1024), 'KB)');
    
    // Check if response is too large (Railway limit ~1MB)
    if (responseSize > 800000) { // 800KB threshold
      console.warn('‚ö†Ô∏è Large response detected, compressing HTML content');
      // Keep essential data but compress HTML
      responseData.htmlContent = result.htmlContent; // Let compression middleware handle it
      responseData.contentSize = result.htmlContent?.length || 0;
    }
    
    // Send response with proper headers
    res.setHeader('Content-Type', 'application/json');
    res.setHeader('Cache-Control', 'no-cache');
    res.status(200).json(responseData);
    
    console.log('üì§ Response sent successfully');
    
  } catch (error) {
    console.error('‚ùå API Error:', error.message);
    console.error('üîç Error type:', error.constructor.name);
    console.error('üîç Memory usage on error:', process.memoryUsage().heapUsed / 1024 / 1024, 'MB');
    
    // Ensure response hasn't been sent already
    if (res.headersSent) {
      console.error('‚ùå Headers already sent, cannot send error response');
      return;
    }
    
    // Handle specific error types
    if (error.message?.includes('overloaded') || error.status === 529) {
      res.status(503).json({
        error: 'Service temporarily overloaded',
        message: 'Claude AI is temporarily overloaded. Please try again in a few minutes.',
        timestamp: new Date().toISOString(),
        retryAfter: 60
      });
    } else if (error.message?.includes('timeout') || error.message?.includes('Generation timeout')) {
      res.status(504).json({
        error: 'Request timeout',
        message: 'The request took too long to process. Please try again.',
        timestamp: new Date().toISOString()
      });
    } else if (error.status === 400) {
      res.status(400).json({
        error: 'Bad request',
        message: error.message || 'Invalid request parameters',
        timestamp: new Date().toISOString()
      });
    } else {
      res.status(500).json({
        error: 'Internal server error',
        message: error.message || 'An unexpected error occurred',
        timestamp: new Date().toISOString()
      });
    }
  }
});

// NEW API ENDPOINT: Elite Landing Page Generation with Section Selection
app.post('/api/generate-elite-landing', async (req, res) => {
  console.log('üöÄ Elite Landing Page Generation Request');
  
  try {
    const { sections, ...formData } = req.body;
    
    // Import elite-multi-gen functions
    const eliteGen = require('./elite-multi-gen-api');
    
    // Transform form data to match elite-multi-gen format
    const userInput = {
      email: formData.email,
      page_style: formData.page_style,
      form_integration: formData.form_integration || 'yes',
      brand_matching: 'custom_colors',
      website_url: formData.website_url || '',
      primary_color: formData.primary_color || '#6366f1',
      secondary_color: formData.secondary_color || '#f59e0b',
      company_name: formData.company_name,
      target_market: formData.target_market,
      business_description: formData.business_description,
      design_instructions: formData.design_instructions || '',
      primary_goal: formData.primary_goal,
      business_email: formData.business_email,
      phone_number: formData.phone_number || ''
    };
    
    // Generate landing page with selected sections
    const result = await eliteGen.generateSectionsWithSelection(userInput, sections);
    
    if (result.success) {
      const fileName = `${formData.company_name.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase()}-landing-page.html`;
      
      // Send email if email is provided
      if (formData.email) {
        await sendEmailNotification(formData, {
          fileName: fileName,
          htmlContent: result.htmlContent
        });
      }
      
      res.json({
        success: true,
        htmlContent: result.htmlContent,
        fileName: fileName
      });
    } else {
      throw new Error(result.error || 'Generation failed');
    }
    
  } catch (error) {
    console.error('‚ùå Elite generation error:', error);
    res.status(500).json({
      success: false,
      error: error.message || 'Failed to generate landing page'
    });
  }
});

// SSE endpoint for real-time progress updates
app.get('/api/progress/:sessionId', (req, res) => {
  const sessionId = req.params.sessionId;
  
  // Set SSE headers
  res.writeHead(200, {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache',
    'Connection': 'keep-alive',
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'Cache-Control'
  });

  // Store the response object for this session
  if (!global.progressConnections) {
    global.progressConnections = new Map();
  }
  global.progressConnections.set(sessionId, res);

  // Send initial connection confirmation
  res.write(`data: ${JSON.stringify({
    type: 'connected',
    message: 'Progress tracking connected',
    timestamp: Date.now()
  })}\n\n`);

  // Clean up on client disconnect
  req.on('close', () => {
    if (global.progressConnections) {
      global.progressConnections.delete(sessionId);
    }
  });
});

// Function to send progress updates to a specific session
function sendProgressUpdate(sessionId, data) {
  if (global.progressConnections && global.progressConnections.has(sessionId)) {
    const res = global.progressConnections.get(sessionId);
    try {
      res.write(`data: ${JSON.stringify({
        ...data,
        timestamp: Date.now()
      })}\n\n`);
    } catch (error) {
      console.error('Error sending progress update:', error);
      global.progressConnections.delete(sessionId);
    }
  }
}

// API ENDPOINT: Get list of generated sections
app.get('/api/sections', (req, res) => {
  try {
    const eliteGen = require('./elite-multi-gen-api');
    const sections = eliteGen.getSectionsList();
    
    res.json({
      success: true,
      sections: sections,
      count: sections.length,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('‚ùå Error getting sections:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// API ENDPOINT: Serve individual section files
app.get('/temp/sections/:filename', (req, res) => {
  try {
    const filename = req.params.filename;
    const sectionsDir = path.join(__dirname, 'temp', 'sections');
    const filePath = path.join(sectionsDir, filename);
    
    // Security check - ensure file is within sections directory
    if (!filePath.startsWith(sectionsDir)) {
      return res.status(400).json({ error: 'Invalid file path' });
    }
    
    if (fs.existsSync(filePath)) {
      const content = fs.readFileSync(filePath, 'utf8');
      res.setHeader('Content-Type', 'text/html');
      res.send(content);
    } else {
      res.status(404).json({ error: 'Section file not found' });
    }
  } catch (error) {
    console.error('‚ùå Error serving section:', error);
    res.status(500).json({ error: 'Failed to serve section file' });
  }
});

// API ENDPOINT: Serve final generated files (for preview)
app.get('/temp/final/:filename', (req, res) => {
  try {
    const filename = req.params.filename;
    const finalDir = path.join(__dirname, 'temp', 'final');
    const filePath = path.join(finalDir, filename);
    
    // Security check - ensure file is within final directory
    if (!filePath.startsWith(finalDir)) {
      return res.status(400).json({ error: 'Invalid file path' });
    }
    
    if (fs.existsSync(filePath)) {
      const content = fs.readFileSync(filePath, 'utf8');
      res.setHeader('Content-Type', 'text/html');
      res.send(content);
    } else {
      res.status(404).json({ error: 'Final file not found' });
    }
  } catch (error) {
    console.error('‚ùå Error serving final file:', error);
    res.status(500).json({ error: 'Failed to serve final file' });
  }
});

// API ENDPOINT: Download final generated files
app.get('/api/download/:filename', (req, res) => {
  try {
    const filename = req.params.filename;
    const finalDir = path.join(__dirname, 'temp', 'final');
    const filePath = path.join(finalDir, filename);
    
    // Security check - ensure file is within final directory
    if (!filePath.startsWith(finalDir)) {
      return res.status(400).json({ error: 'Invalid file path' });
    }
    
    if (fs.existsSync(filePath)) {
      const content = fs.readFileSync(filePath, 'utf8');
      
      // Set headers for download
      res.setHeader('Content-Type', 'text/html');
      res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
      res.setHeader('Content-Length', Buffer.byteLength(content, 'utf8'));
      
      console.log(`üì• File download: ${filename}`);
      res.send(content);
    } else {
      res.status(404).json({ error: 'File not found for download' });
    }
  } catch (error) {
    console.error('‚ùå Error downloading file:', error);
    res.status(500).json({ error: 'Failed to download file' });
  }
});

// Serve the main page
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'index.html'));
});

// Configure server timeouts
const server = app.listen(PORT, '0.0.0.0', () => {
  console.log(`üöÄ CliqPages server running on port ${PORT}`);
  console.log(`üì± Local: http://localhost:${PORT}`);
  console.log(`üåç Environment: ${process.env.NODE_ENV || 'development'}`);
  console.log(`‚úÖ Server bound to 0.0.0.0:${PORT}`);
  console.log(`üíæ Memory usage:`, process.memoryUsage());
});

// Set server timeouts to handle long-running requests (increased for section generation)
server.timeout = 720000; // 12 minutes for section-by-section generation
server.keepAliveTimeout = 720000; // 12 minutes
server.headersTimeout = 725000; // Slightly higher than keepAliveTimeout

// Memory monitoring
setInterval(() => {
  const memUsage = process.memoryUsage();
  const heapUsedMB = Math.round(memUsage.heapUsed / 1024 / 1024);
  const heapTotalMB = Math.round(memUsage.heapTotal / 1024 / 1024);
  
  if (heapUsedMB > 200) { // Alert if using more than 200MB
    console.warn(`‚ö†Ô∏è High memory usage: ${heapUsedMB}MB / ${heapTotalMB}MB`);
  }
  
  // Force garbage collection if available
  if (global.gc && heapUsedMB > 300) {
    console.log('üóëÔ∏è Running garbage collection...');
    global.gc();
  }
}, 30000); // Check every 30 seconds

// Handle server errors
server.on('error', (error) => {
  console.error('‚ùå Server error:', error);
  if (error.code === 'EADDRINUSE') {
    console.error(`Port ${PORT} is already in use`);
  }
});

// Graceful shutdown
process.on('SIGTERM', () => {
  console.log('üõë SIGTERM received, shutting down gracefully');
  server.close(() => {
    console.log('‚úÖ Server closed');
    process.exit(0);
  });
});

module.exports = app; 